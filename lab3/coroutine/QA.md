# Coroutine 相关 QA

## C 语言基础相关问题

### `__ctx` 与 `__ctx*`

`__ctx`（`char[120]`）类型的变量本来就是一个地址，为什么传参不直接传 `__ctx` 而是传 `__ctx*`？

```C++
void __err_stk_push(__ctx* ctx);
```

解答：

设有变量 `__ctx a` 或者 `char a[120]`：

1. a 和 &a 指向的是同一个地址
2. a 的类型是 `char*`，&a 的类型是 `char(*)[120]`，只在指针运算（如 `a+=1`）时不同

### `malloc` 分配的地址

`malloc` 分配堆上的地址，和栈上的地址不同。堆和栈的关系如下图：

![malloc 分配的地址](heap.png)

## Coroutine 程序运行相关问题

### 明明输出了 testx PASSED，但是却又报错

对应的测试函数运行完之后，检查发现内存中应该清除的上下文没有清除，一般是实现有误。或者把栈帧搞崩了没法 return。

善用 GDB 检查错误在哪里，为什么会出错。

### printf 或 malloc 等函数内发生段错误

Task 1.1 有提到过“`system` 内部某些汇编语句对栈的对齐要求很高”，对于这些函数也是一样。GDB 看看是不是停在使用 xmm 寄存器的语句，需要 rsp16 字节对齐。

### 我不知道如何在 try/catch/throw/generator 里面判断 test 是否怎么怎么样

不需要知道。你实现的是基础设施，并不需要知道用户怎么使用。如果你发现了用户的实现有潜在的 bug（比如内存泄漏），你也不需要去修正。

### 为什么要用 malloc 申请一段空间当做栈？

如果你这样实现生成器：
主函数创建生成器 A，分配 A 的栈帧在主函数栈帧下面，然后主函数没有启动生成器 A 而是调用了其他函数，新的栈帧直接破坏了你分配给 A 的栈帧。
如上文所说，malloc 分配的空间在堆里面，可以视作和栈不相关。

本次 lab 保证生成器内用到的栈帧都不大，你可以放心使用 malloc 申请一段空间为其所用。

### try与生成器的嵌套

什么是“在外部处理生成器内部未处理的 `throw`”？

解答：

假设有生成器 a：

```python
def main():
    try{
        a.send(1)
    }
    catch{
        print(error)
    }
```

如果 a 里面没有 try 直接 throw，程序应该回到主函数被 catch 住而不是直接爆炸。不然就成了明明 try 代码块里面发生了异常，却没有 catch 住，直接爆炸，那还要 try 来干啥呢。

如果 a 调用了生成器 b，b 调用了生成器 c，c 直接 throw，同理。

### 如何配置初始上下文？

做完前面的 lab，结合 lab 说明，你应该知道：

1. restore 具有修改 rip、跳转程序当前正在执行的位置的效果。
2. 假设两个生成器已经跑起来了，你可以随时切换当前正在执行的生成器，并从上次暂停的位置继续运行下去。
3. 构造生成器时，通过伪造“好像生成器已经跑起来了”的状态，这样下次 send 的时候就可以直接切换过去了。
